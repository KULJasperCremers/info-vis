<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.min.js"></script>
    <script src="https://d3js.org/d3.v6.min.js"></script>

    <link href="https://cdn.jsdelivr.net/npm/nouislider/distribute/nouislider.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/nouislider/distribute/nouislider.min.js"></script>

    <link href="/css/styles.css" rel="stylesheet">
</head>
<body>
        <div class="row">
            <div class="col chart" style="margin-right: -37;">
                <h1 class="text-center" id="countryHeader">Country</h1>
                <div id="graph"></div>
            </div>
            <div class="col-1 chart" style="margin-right: -50;">
                <div  style="margin-top: 200%;">
                    <p><strong>Leanings</strong></p>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-far-left" style="background-color: #a6cee3;" onclick="selectLeaning(this, 'Far Left')">
                        <label class="form-check-label" for="radio-far-left">
                        <strong>Far left</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-left" style="background-color: #1f78b4;" onclick="selectLeaning(this, 'Left')">
                        <label class="form-check-label" for="radio-left">
                            <strong>Left</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-center-left" style="background-color: #b2df8a;" onclick="selectLeaning(this, 'Center Left')">
                        <label class="form-check-label" for="radio-center-left">
                            <strong>Center Left</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-center" style="background-color: #33a02c;" onclick="selectLeaning(this, 'Center')">
                        <label class="form-check-label" for="radio-center">
                            <strong>Center</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-center-right" style="background-color:#fb9a99;" onclick="selectLeaning(this, 'Center Right')">
                        <label class="form-check-label" for="radio-center-right">
                            <strong>Center Right</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-right" style="background-color:#e31a1c;" onclick="selectLeaning(this, 'Right')">
                        <label class="form-check-label" for="radio-right">
                            <strong>Right</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-far-right" checked style="background-color:#fdbf6f;" onclick="selectLeaning(this, 'Far Right')">
                        <label class="form-check-label" for="radio-far-right">
                            <strong>Far Right</strong>
                        </label>
                    </div>
                </div>
            </div>
            <div class="col">
            <div class="row chart">
                <h1 class="text-center">Map filters</h1>
                <div class="row">
                    <p>Between <span id="slider-value-lower"></span> and <span id="slider-value-upper"></span></p>
                    <div id="slider" style="margin-bottom: 1rem; margin-left: 1rem; margin-right: 1rem;"></div>
                </div>
            </div>
            <div class="row chart">
                <div class="col chart" style="position: relative;">
                    
                    <div id="map"></div>
                </div>
            </div>
            </div>
        </div>

<script src="datahelper.js"></script>
<script src="map.js"></script>
<script>

    let data;
    let all_dates = [];
    //d3.json("../json/allCountryData.json").then(function(d) {
    d3.json("../json/allCountryData.json").then(function(d) {
        data = d;
        console.log(data)
        
        Object.values(newCountryCodes).forEach(element => {
            var dates = get_all_dates(data, element);
            all_dates.push(...dates); 
        });

        all_dates = [...new Set(all_dates)];
        all_dates.sort((a, b) => a - b);

        selectCountry("Belgium");

        document.getElementById("radio-far-right").checked = true;
        selectLeaning(
            document.getElementById("radio-far-right"),
            'Far Right'
        )
    });
    
    var cellSize = 400;
    var selectedCountry = undefined; 
    var selectedLeaning = "Far Right"

    var selectedFromDate = undefined;
    var selectedToDate = undefined;

    var selectedLeanings = [];

    function selectLeaning(checkbox, leaning) {
        if (!checkbox.checked) {
            // If the leaning is already in the array, remove it
            const index = selectedLeanings.indexOf(leaning);
            selectedLeanings.splice(index, 1);
        } else {
            // Otherwise, add the leaning to the array
            selectedLeanings.push(leaning);
        }
        drawMap(countryColorFuncGrowth);
        drawGraphs();
    }

    function drawGraphs() {
        // Get the parent container
        var graphContainer = document.getElementById('graph').parentNode;
            
        // Remove all child elements of the graphContainer
        while (graphContainer.firstChild) {
            graphContainer.removeChild(graphContainer.firstChild);
        }

        d3.select(graphContainer)
            .append("h1")
            .attr("id", "countryHeader")
            .style("text-align", "center")
            .text(selectedCountry);
        
        // Create a new 'graph' element
        var svg = d3.select(graphContainer)
            .append("div")
            .attr("id", "graph");
    
        // Draw the first graph
        graph(selectedCountry, selectedFromDate, selectedToDate, svg);
    
        // Draw the second graph
        graphSurvey(selectedCountry, selectedFromDate, selectedToDate, svg);
    }

    var leaning_mapper = {
        "Center": "center",
        "Center Left": "center-left",
        "Center Right": "center-right",
        "Far Right": "far-right",
        "Left": "left",
        "Far Left": "far-left",
        "Right": "right"
    }

    function countryColorFunc(country) {
        return "white";
    }


    function countryColorFuncGrowth(country) {
        if (selectedToDate === undefined || selectedFromDate === undefined) {
            return "white";
        }

        var leaning_data = get_percentage_leaning_data_between(data, newCountryCodes[country], selectedFromDate, selectedToDate);
        var dates = Object.keys(leaning_data);

        //leaning = leaning_mapper[selectedLeaning]
        first = leaning_data[dates[0]]
        last = leaning_data[dates.at(-1)]

        var aggregateFirst = 0;
        var aggregateLast = 0;

        selectedLeanings.forEach(l => {
            var leaning = l;
            var mapped_leaning = leaning_mapper[l];
           
            if (
                first != undefined && last !== undefined && 
                first[mapped_leaning] && last[mapped_leaning]
            ) {
                aggregateFirst += first[mapped_leaning];
                aggregateLast += last[mapped_leaning];
            }
        });
        var growth = (aggregateLast - aggregateFirst)
        var normalized_growth = (growth + 100) / 200;
        return [growth, interpolateRedGreen(normalized_growth)]
    }

    function OnHoverCountry(countryCode) {
    }

    function OnClickCountry(countryCode) {
        // console.log("click: " + countryCode);
        selectCountry(countryCode)
    }

    function drawMap(colorFunc) {
        d3.select('#map').selectAll('*').remove();
        var mapContainer = document.getElementById('map').parentNode;
        var w = mapContainer.clientWidth;
        var h = w * 1;  
        var svg = AppendMap('#map', OnHoverCountry, OnClickCountry, colorFunc, w, h);
    }

    function selectCountry(country) {
        selectedCountry = country;
        document.getElementById("countryHeader").innerText= country;

        console.log("T")

        var dates = get_all_dates(data, newCountryCodes[country]);
        selectedFromDate = dates.at(0);
        selectedToDate = dates.at(-1);

        var slider = document.getElementById('slider');

        if (!slider.noUiSlider) {
            noUiSlider.create(slider, {
            margin: 2,
            start: [0, dates.length], // Initial values: [lower, upper]
            connect: true, // Display a colored bar between the handles
            range: {
                'min': 0,
                'max': dates.length
            }
            });

            slider.noUiSlider.on('update', function (values, handle) {
                var valueLower = document.getElementById('slider-value-lower');
                var valueUpper = document.getElementById('slider-value-upper');

                valueLower.innerHTML = dates[Math.round(values[0])];
                valueUpper.innerHTML = dates[Math.round(values[1] - 1)];

                selectedFromDate =  dates[Math.round(values[0])];
                selectedToDate =  dates[Math.round(values[1] - 1)];

                drawMap(countryColorFuncGrowth);
                drawGraphs();
            });
        }
        else {
            slider.noUiSlider.updateOptions({
                start: [0, dates.length], // Initial values: [lower, upper]
                margin: 2,
                connect: true, // Display a colored bar between the handles
                range: {
                    'min': 0,
                    'max': dates.length
                }
            });

            slider.noUiSlider.on('update', function (values, handle) {
                var valueLower = document.getElementById('slider-value-lower');
                var valueUpper = document.getElementById('slider-value-upper');

                valueLower.innerHTML = dates[Math.round(values[0])];
                valueUpper.innerHTML = dates[Math.round(values[1] - 1)];

                selectedFromDate =  dates[Math.round(values[0])];
                selectedToDate =  dates[Math.round(values[1] - 1)];

                drawMap(countryColorFuncGrowth);
                drawGraphs();
            });
        }
        //drawMap(countryColorFuncGrowth);
        //drawGraphs();
    }

    drawMap(countryColorFunc);

    /** function graph() {
        let growthData = aggregateDashboardDataForCountryBetweenYears(cdata, "Belgium", 2003, 2019);
        let years = Object.keys(growthData.electionGrowth).map(Number);
        let politicalLeanings = ["far-left", "left", "center-left", "center", "center-right", "right", "far-right"];

        console.log(growthData)

        // Get the graphContainer
        var graphContainer = document.getElementById('graph').parentNode;

        // Get the width and height of the graphContainer
        var width = graphContainer.clientWidth;
        var height = graphContainer.clientHeight;

        // Create an SVG in the graphContainer
        var svg = d3.select(graphContainer)
        .append("svg")
            .attr("width", width - 25)
            .attr("height", height / 2);

        // Define the scales
        let xScale = d3.scaleBand().domain(years).range([0, width]);
        let colorScale = d3.scaleOrdinal().domain(politicalLeanings).range(colors);
        let yScaleLeft = d3.scaleLinear().domain([-1, 1]).range([height, 0]);
        let yScaleRight = d3.scaleLinear().domain([-50, 160]).range([height, 0]);

        // Define the line generator
        let line = d3.line()
            .x((d) => xScale(d.year))
            .y((d) => yScaleLeft(d.absoluteGrowth));

            console.log(graphContainer.clientWidth, graphContainer.clientHeight);

        // Loop over the years
        for (let year of years) {
            // Loop over the political leanings
            for (let leaning of politicalLeanings) {
                // Get the growth data for this year and leaning
                let growth = growthData.electionGrowth[year][leaning];

                // Check if growth is defined
                if (growth) {
                    // Generate a line for the absolute growth
                    svg.append("path")
                        .datum(growth)
                        .attr("fill", "none")
                        .attr("stroke", colorScale(leaning))
                        .attr("d", line);

                    // Generate a bar for the relative growth
                    svg.append("rect")
                        .attr("class", "bar")
                        .attr("x", xScale(year))
                        .attr("y", yScaleRight(growth.relativeGrowth))
                        .attr("width", xScale.bandwidth())
                        .attr("height", height - yScaleRight(growth.relativeGrowth))
                        .attr("fill", colorScale(leaning));
                }
            }
        }

        // Add axes and labels
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(xScale));

        svg.append("g")
            .call(d3.axisLeft(yScaleLeft));

        svg.append("g")
            .attr("transform", "translate(" + width + ",0)")
            .call(d3.axisRight(yScaleRight));

                
    }
    **/

    function interpolateRedGreen(t) {
        if (t < 0 || t > 1) {
            return 'Value must be between 0 and 1';
        }

        // Calculate red and green components
        const red = 255 * (1 - t);
        const green = 255 * t;

        // Convert each component to an integer
        const r = Math.round(red);
        const g = Math.round(green);

        // Return the color in hexadecimal format
        return `rgb(${r}, ${g}, 0)`;
    }

    function graph(country, date1, date2, svg) {
        var newCountryCodes = {
            "Austria": "AT",
            "Belgium": "BE",
            "Germany": "DE",
            "Denmark": "DK",
            "Greece": "EL",
            "Spain": "ES",
            "Finland": "FI",
            "France": "FR",
            "Ireland": "IE",
            "Italy": "IT",
            "Netherlands": "NL",
            "Portugal": "PT",
            "Sweden": "SE", 
        }

        var growthData = [];
        var allYears = [];
        for (var year in data[newCountryCodes[country]].electionGrowth) {
            if (year >= date1 && year <= date2) {
                for (var leaning in data[newCountryCodes[country]].electionGrowth[year]) {
                    var growth = data[newCountryCodes[country]].electionGrowth[year][leaning];
                    growthData.push({
                        leaning: leaning,
                        year: year,
                        growth: growth.absolute
                    });
                    allYears.push(year);
                }
            }
        }

        // Find the min and max growth values
        var growthMin = d3.min(growthData, function(d) { return d.growth; });
        var growthMax = d3.max(growthData, function(d) { return d.growth; });

        // Create a scale for your growth data
        var growthScale = d3.scaleLinear()
            .domain([growthMin, growthMax])
            .range([-1, 1]);

        // Get the parent container
        var graphContainer = document.getElementById('graph').parentNode;

        // Remove the old SVG
        //d3.select("#graph").remove();

        // Get the width and height of the graphContainer
        var width = graphContainer.clientWidth;
        var height = graphContainer.clientHeight;

        // Create an SVG in the graphContainer
        svg = d3.select(graphContainer)
        .append("svg")
            .attr("id", "graph")
            .attr("width", width - 25)
            .attr("height", height / 2);

        // Define margins for the x-axis
        var xAxisMargin = 50;

        // Create a scale for your x-axis
        var x = d3.scalePoint()
        .domain(allYears) 
        .range([xAxisMargin, width - 25 - xAxisMargin]); // Leave space on both sides of the x-axis

        // Create a scale for your y-axis
        var y = d3.scaleLinear()
        .domain([-1, 1]) 
        .range([height / 2 - 20, 25]); 

        // Add the y-axis to your SVG
        svg.append("g")
        .attr("transform", "translate(" + xAxisMargin + ",0)")
        .call(d3.axisLeft(y).ticks(5));

        // Add grid lines for each x-axis tick
        svg.selectAll(".grid-line")
            .data(x.domain())
            .enter()
            .append("line")
            .attr("class", "grid-line")
            .attr("stroke", "#ccc") // Change this to the color you want
            .attr("stroke-opacity", 0.9) // Make the lines slightly opaque
            .attr("y1", 0)
            .attr("y2", height)
            .attr("x1", function(d) { return x(d); })
            .attr("x2", function(d) { return x(d); });

        // Define color scale
        var color = d3.scaleOrdinal()
        .domain(["far-left", "left", "center-left", "center", "center-right", "right", "far-right"])
        .range(["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"]);

        // Define your line
        var line = d3.line()
            .x(function(d) { return x(d.year); }) 
            .y(function(d) { return y(d.growth); });

        // Group the data by leaning
        var dataByLeaning = Array.from(d3.group(growthData, d => d.leaning));

        // Scale the growth data in dataByLeaning
        dataByLeaning = dataByLeaning.map(([key, values]) => {
            return [key, values.map(d => ({...d, growth: growthScale(d.growth)}))];
        });

        // Filter the data to include only the selected leanings
        var filteredDataByLeaning = []
        
        // Filter the data to include only the selected leanings
        var filteredDataByLeaning = dataByLeaning.filter(function([key, values]) {
            for (var l in selectedLeanings) {
                if (leaning_mapper[selectedLeanings[l]] == key) {
                    return true;
                }
            }
            return false;
        });

        //console.log(filteredDataByLeaning)

        // Append your lines to the SVG
        filteredDataByLeaning.forEach(function([key, values]) {
            svg.append("path")
            .datum(values)
            .attr("fill", "none")
            .attr("stroke", color(key))
            .attr("stroke-width", 1.5)
            .attr("d", line);
        });

        // Add the x-axis to your SVG
        var xAxis = svg.append("g")
        .attr("transform", "translate(0," + y(0) + ")")
        .call(d3.axisBottom(x));

        // Move the x-axis labels to the bottom of the grid lines
        xAxis.selectAll("text")
        .attr("dy", y(0) - 15); // Adjust the 15 to move the labels up or down

    }

    function graphSurvey(country, date1, date2, svg) {
        var newCountryCodes = {
            "Austria": "AT",
            "Belgium": "BE",
            "Germany": "DE",
            "Denmark": "DK",
            "Greece": "EL",
            "Spain": "ES",
            "Finland": "FI",
            "France": "FR",
            "Ireland": "IE",
            "Italy": "IT",
            "Netherlands": "NL",
            "Portugal": "PT",
            "Sweden": "SE", 
        }

        var growthData = [];
        var allYears = [];
        for (var year in data[newCountryCodes[country]].surveyGrowth) {
            if (year >= date1 && year <= date2) {
                for (var leaning in data[newCountryCodes[country]].surveyGrowth[year]) {
                    var growth = data[newCountryCodes[country]].surveyGrowth[year][leaning];
                    //console.log(data[newCountryCodes[country]].surveyGrowth[year][leaning])
                    growthData.push({
                        leaning: leaning,
                        year: year,
                        growth: growth.satisfaction.absolute
                        /**growth: {
                            "happy": growth.happy,
                            "satisfaction": growth.satisfaction,
                            "trust_country": growth.trust_country,
                            "trust_eu": growth.trust_eu
                        }**/
                    });
                    allYears.push(year);
                }
            }
        }

        /**
        var maxGrowth = { happy: -Infinity, satisfaction: -Infinity, trust_country: -Infinity, trust_eu: -Infinity };
        var minGrowth = { happy: Infinity, satisfaction: Infinity, trust_country: Infinity, trust_eu: Infinity };
        
        for (var item of growthData) {
            for (var category in item.growth) {
                var absoluteGrowth = item.growth[category].absolute;
                if (absoluteGrowth > maxGrowth[category]) {
                    maxGrowth[category] = absoluteGrowth;
                }
                if (absoluteGrowth < minGrowth[category]) {
                    minGrowth[category] = absoluteGrowth;
                }
            }
        }
        
        console.log('Max growth:', maxGrowth);
        console.log('Min growth:', minGrowth);
        **/
        // Find the min and max growth values
        var growthMin = d3.min(growthData, function(d) { return d.growth; });
        var growthMax = d3.max(growthData, function(d) { return d.growth; });

        // Create a scale for your growth data
        var growthScale = d3.scaleLinear()
            .domain([growthMin, growthMax])
            .range([growthMin, growthMax]);

        // Get the parent container
        var graphContainer = document.getElementById('graph').parentNode;

        // Remove the old SVG
        //d3.select("#graph").remove();

        // Get the width and height of the graphContainer
        var width = graphContainer.clientWidth;
        var height = graphContainer.clientHeight;

        // Create an SVG in the graphContainer
        svg = d3.select(graphContainer)
        .append("svg")
            .attr("id", "graph")
            .attr("width", width - 25)
            .attr("height", height / 2);

        // Define margins for the x-axis
        var xAxisMargin = 50;

        // Create a scale for your x-axis
        var x = d3.scalePoint()
        .domain(allYears) 
        .range([xAxisMargin, width - 25 - xAxisMargin]); // Leave space on both sides of the x-axis

        // Create a scale for your y-axis
        var y = d3.scaleLinear()
        .domain([growthMin, growthMax]) 
        .range([height / 2 - 20, 25]); 

        // Add the y-axis to your SVG
        svg.append("g")
        .attr("transform", "translate(" + xAxisMargin + ",0)")
        .call(d3.axisLeft(y).ticks(5));

        // Add grid lines for each x-axis tick
        svg.selectAll(".grid-line")
            .data(x.domain())
            .enter()
            .append("line")
            .attr("class", "grid-line")
            .attr("stroke", "#ccc") // Change this to the color you want
            .attr("stroke-opacity", 0.9) // Make the lines slightly opaque
            .attr("y1", 0)
            .attr("y2", height)
            .attr("x1", function(d) { return x(d); })
            .attr("x2", function(d) { return x(d); });

        // Define color scale
        var color = d3.scaleOrdinal()
        .domain(["far-left", "left", "center-left", "center", "center-right", "right", "far-right"])
        .range(["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"]);

        // Define your line
        var line = d3.line()
            .x(function(d) { return x(d.year); }) 
            .y(function(d) { return y(d.growth); });

        // Group the data by leaning
        var dataByLeaning = Array.from(d3.group(growthData, d => d.leaning));

        /**
        // Scale the growth data in dataByLeaning
        dataByLeaning = dataByLeaning.map(([key, values]) => {
            return [key, values.map(d => ({...d, growth: growthScale(d.growth)}))];
        });
        **/
        dataByLeaning = dataByLeaning.map(([key, values]) => {
            let cumulativeGrowth = 0;
            return [key, values.map(d => {
                cumulativeGrowth += d.growth;
                return {...d, growth: cumulativeGrowth};
            })];
        });

        // Filter the data to include only the selected leanings
        var filteredDataByLeaning = []
        
        // Filter the data to include only the selected leanings
        var filteredDataByLeaning = dataByLeaning.filter(function([key, values]) {
            for (var l in selectedLeanings) {
                if (leaning_mapper[selectedLeanings[l]] == key) {
                    return true;
                }
            }
            return false;
        });


        // Append your lines to the SVG
        filteredDataByLeaning.forEach(function([key, values]) {
            svg.append("path")
            .datum(values)
            .attr("fill", "none")
            .attr("stroke", color(key))
            .attr("stroke-width", 1.5)
            .attr("d", line);
        });

        // Add the x-axis to your SVG
        var xAxis = svg.append("g")
        .attr("transform", "translate(0," + y(0) + ")")
        .call(d3.axisBottom(x));

        // Move the x-axis labels to the bottom of the grid lines
        xAxis.selectAll("text")
        .attr("dy", y(0) - 15); // Adjust the 15 to move the labels up or down

    }

  

</script>

</body>

</html>

<style>

</style>