<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.min.js"></script>
    <script src="https://d3js.org/d3.v6.min.js"></script>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""></script>

    <link href="https://cdn.jsdelivr.net/npm/nouislider/distribute/nouislider.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/nouislider/distribute/nouislider.min.js"></script>

    <link href="/css/styles.css" rel="stylesheet">
</head>
<body>
        <div class="row">
            <div class="col" style="margin-right: -37;">
                <div class="row chart"><h1  class="text-center" id="countryHeader">Country</h1></div>
                <div id="graph"></div>
            </div>
            <div class="col-1" style="margin-right: -50;" id="radio-leanings">
                <div  class="chart2" style="margin-top: 110%;">
                    <p><strong>Leanings</strong></p>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-far-left" style="background-color: #a6cee3;" onclick="selectLeaning(this, 'Far Left')">
                        <label class="form-check-label" for="radio-far-left">
                        <strong>Far left</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-left" style="background-color: #1f78b4;" onclick="selectLeaning(this, 'Left')">
                        <label class="form-check-label" for="radio-left">
                            <strong>Left</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-center-left" style="background-color: #b2df8a;" onclick="selectLeaning(this, 'Center Left')">
                        <label class="form-check-label" for="radio-center-left">
                            <strong>Center Left</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-center" style="background-color: #33a02c;" onclick="selectLeaning(this, 'Center')">
                        <label class="form-check-label" for="radio-center">
                            <strong>Center</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-center-right" style="background-color:#fb9a99;" onclick="selectLeaning(this, 'Center Right')">
                        <label class="form-check-label" for="radio-center-right">
                            <strong>Center Right</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-right" style="background-color:#e31a1c;" onclick="selectLeaning(this, 'Right')">
                        <label class="form-check-label" for="radio-right">
                            <strong>Right</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" name="flexRadioDefault" id="radio-far-right" checked style="background-color:#fdbf6f;" onclick="selectLeaning(this, 'Far Right')">
                        <label class="form-check-label" for="radio-far-right">
                            <strong>Far Right</strong>
                        </label>
                    </div>
                </div>
                <div class="chart2" style="margin-top: 10%;">
                    <p><strong>Survey</strong></p>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="radio-survey" id="radio-happy" style="background-color:#FFCC0D;" onclick="selectSurvey(this, 'happy')" checked>
                        <label class="form-check-label" for="radio-happy">
                        <strong>Happiness</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="radio-survey" id="radio-satisfaction" style="background-color:#00796B;" onclick="selectSurvey(this, 'satisfaction')">
                        <label class="form-check-label" for="radio-satisfaction">
                            <strong>Satisfaction</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="radio-survey" id="radio-trust-country" style="background-color:#BF2669;" onclick="selectSurvey(this, 'trust_country')">
                        <label class="form-check-label" for="radio-trust-country">
                            <strong>Trust Country</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="radio-survey" id="radio-trust-eu" style="background-color:#637d92;" onclick="selectSurvey(this, 'trust_eu')">
                        <label class="form-check-label" for="radio-trust-eu">
                            <strong>Trust EU</strong>
                        </label>
                    </div>
                </div>
                <div  class="chart2" style="margin-top: 10%;">
                    <p><strong>Map</strong></p>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="radio-map" id="radio-largest-growth" style="background-color:#FFCC0D;" onclick="selectMapMode(this, 'largest-growth')" checked>
                        <label class="form-check-label" for="radio-largest-growth">
                            <strong>Largest growth</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="radio-map" id="radio-largest-decline" style="background-color:#00796B;" onclick="selectMapMode(this, 'largest-decline')">
                        <label class="form-check-label" for="radio-largest-decline">
                            <strong>Largest decline</strong>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="radio-map" id="radio-cumulative-growth" style="background-color:#BF2669;" onclick="selectMapMode(this, 'cumulative-growth')">
                        <label class="form-check-label" for="radio-cumulative-growth">
                            <strong>Cumulative growth</strong>
                        </label>
                    </div>
                </div>
            </div>
            <div class="col">
            <div class="row chart">
                <h1 class="text-center">Date Selection</h1>
                <div class="row">
                    <p>Between <span id="slider-value-lower"></span> and <span id="slider-value-upper"></span></p>
                    <div id="slider" style="margin-bottom: 3rem; margin-left: 1rem; margin-right: 1rem;"></div>
                </div>
            </div>
            <div class="row chart">
                    <div id="map"></div>
            </div>
            </div>
        </div>

<script src="datahelper.js"></script>
<script src="map.js"></script>
<script>

    let data;
    let all_dates = [];
    

    let map;
    let geodata;
    let geojsonLayer ;
    
    var cellSize = 400;
    var selectedCountry = undefined; 
    var selectedLeaning = "Far Right"

    var selectedFromDate = undefined;
    var selectedToDate = undefined;

    var selectedSurveyType = "happy";
    var selectedMapMode = "largest-growth";
    var selectedCountryColorFunc = countryColorFuncLargestGrowth;

    var selectedLeanings = [];

    var leaning_colors = {
        "far-left": "#a6cee3",
        "left": "#1f78b4",
        "center-left": "#b2df8a",
        "center": "#33a02c",
        "center-right": "#fb9a99",
        "right": "#e31a1c",
        "far-right": "#fdbf6f"
    }

    let countryColors = {}
    let countryLargest = {}
    let countryPercentages = {}

    //d3.json("../json/allCountryData.json").then(function(d) {
    d3.json("../json/allCountryData.json").then(function(d) {
        data = d;
        
        Object.values(newCountryCodes).forEach(element => {
            var dates = get_all_dates(data, element);
            all_dates.push(...dates); 
        });

        all_dates = [...new Set(all_dates)];
        all_dates.sort((a, b) => a - b);

        selectCountry("Belgium");

        
        document.getElementById("radio-far-left").checked = false;
        document.getElementById("radio-left").checked = false;
        document.getElementById("radio-center-left").checked = false;
        document.getElementById("radio-center").checked = false;
        document.getElementById("radio-center-right").checked = false;
        document.getElementById("radio-right").checked = false;
        document.getElementById("radio-far-right").checked = true;

        selectLeaning(
            document.getElementById("radio-far-right"),
            'Far Right'
        )
        return d3.json("../json/geojson.json");
    }).then(function(d) {
            geodata = d;
            map = L.map('map', { 
                zoomControl: false,
                scrollWheelZoom: false,
                dragging: false,
                touchZoom: false,
                doubleClickZoom: false,
                boxZoom: false
            }).setView([56, 10], 4); // Centered around Europe
            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map);
            geojsonLayer = L.geoJSON(geodata, {
                onEachFeature: function(feature, layer) {
                // Bind a permanent tooltip

                if (feature.properties && feature.properties.name) {
                        layer.bindTooltip(feature.properties.name, {
                        permanent: true,
                        className: 'no-background',
                        direction: 'center', // This attempts to center, might need adjustments based on the shape
                        offset: [0, 0] // Adjust as necessary to better center the tooltip
                    });
                }

                // Add click event listener
                layer.on('click', function() {
                    OnClickCountry(feature.properties.name);
                }
                
                );
                layer.on('mouseover', function() {
                    d3.selectAll(".line").style("opacity", 0.1);  // Gray out all lines
                    d3.selectAll("." + countryLargest[feature.properties.name].replace(/\s+/g, '-')).style("opacity", 1);  // Highlight the hovered line

                    var checkboxes = document.querySelectorAll('#radio-leanings .form-check-input[type="checkbox"]');

                    checkboxes.forEach(element => {
                        if (element.id !== "radio-" + countryLargest[feature.properties.name]) {
                            element.disabled = true;
                        }
                    });

                });
                layer.on('mouseout', function() {
                    d3.selectAll(".line").style("opacity", 1);

                    var checkboxes = document.querySelectorAll('#radio-leanings .form-check-input[type="checkbox"]');

                    checkboxes.forEach(element => {
                            element.disabled = false;
                    });
                });
        }
        }).addTo(map);
    
    
        colorMap();
        colorBorder();
    });



    var countryCodes = {
    "Austria": "AT",
    "Belgium": "BE",
    "Germany": "DE",
    "Denmark": "DK",
    "Greece": "EL",
    "Spain": "ES",
    "Finland": "FI",
    "France": "FR",
    "Ireland": "IE",
    "Italy": "IT",
    "Netherlands": "NL",
    "Portugal": "PT",
    "Sweden": "SE",
}

    function colorMap(leaning = undefined) {
        if (geojsonLayer) {

            for (let key in countryCodes) {
                var outp = selectedCountryColorFunc(key);
                countryPercentages[key] = outp[0];
                countryColors[key] = outp[1];
                countryLargest[key] = outp[2];
            }

            geojsonLayer.setStyle(function(feature) {
                if (leaning === undefined) {
                    return { 
                        color: countryColors[feature.properties.name]
                    };
                }
                else {
                    return { 
                        color: countryLargest[feature.properties.name] === leaning ? countryColors[feature.properties.name] : "white"
                    };
                }
            });

            geojsonLayer.eachLayer(function(layer) {
                if (layer.feature && layer.feature.properties && layer.feature.properties.name) {
                    var newName = countryPercentages[layer.feature.properties.name];
                    layer.setTooltipContent(newName !== "" ? newName + "%" : " ");
                }
            });
        }
    }

    function colorBorder() {
        if (geojsonLayer) {
            geojsonLayer.setStyle(function(feature) {
                let key = feature.properties.name;
                return { 
                    color: countryColors[key],
                    weight: key === selectedCountry ? 5 : 0.5
                };
            });
        }
    }


    function selectLeaning(checkbox, leaning) {
        if (!checkbox.checked) {
            // If the leaning is already in the array, remove it
            const index = selectedLeanings.indexOf(leaning);
            selectedLeanings.splice(index, 1);
        } else {
            // Otherwise, add the leaning to the array
            selectedLeanings.push(leaning);
        }

        console.log(selectedLeanings);

        colorMap();
        drawGraphs();
    }

    function drawGraphs() {
        // Get the parent container
        var graphContainer = document.getElementById('graph').parentNode;
            
        // Remove all child elements of the graphContainer
        while (graphContainer.firstChild) {
            graphContainer.removeChild(graphContainer.firstChild);
        }

        d3.select(graphContainer)
        .append("div")
        .attr("class", "row chart")
        .append("h1")
        .attr("id", "countryHeader")
        .attr("class", "text-center")
        .text(selectedCountry);
        
        // Create a new 'graph' element
        var svg = d3.select(graphContainer)
            .append("div")
            .attr("id", "graph");
    
        // Draw the first graph
        graph(selectedCountry, selectedFromDate, selectedToDate, svg);
    
        // Draw the second graph
        graphSurvey(selectedCountry, selectedFromDate, selectedToDate, svg, selectedSurveyType);
    }

    var leaning_mapper = {
        "Center": "center",
        "Center Left": "center-left",
        "Center Right": "center-right",
        "Far Right": "far-right",
        "Left": "left",
        "Far Left": "far-left",
        "Right": "right"
    }

    function countryColorFunc(country) {
        return ["", "white"];
    }

    function countryColorFuncCumulativeGrowth(country) {
        if (selectedToDate === undefined || selectedFromDate === undefined) {
            return "white";
        }

        var leaning_data = get_percentage_leaning_data_between(data, newCountryCodes[country], selectedFromDate, selectedToDate);
        var dates = Object.keys(leaning_data);

        //leaning = leaning_mapper[selectedLeaning]
        first = leaning_data[dates[0]]
        last = leaning_data[dates.at(-1)]

        var aggregateFirst = 0;
        var aggregateLast = 0;

        selectedLeanings.forEach(l => {
            var leaning = l;
            var mapped_leaning = leaning_mapper[l];
           
            if (
                first != undefined && last !== undefined && 
                first[mapped_leaning] && last[mapped_leaning]
            ) {
                aggregateFirst += first[mapped_leaning];
                aggregateLast += last[mapped_leaning];
            }
        });
        var growth = (aggregateLast - aggregateFirst)
        var normalized_growth = (growth + 100) / 200;
        return [Math.round(growth), interpolateRedGreen(normalized_growth),, ""]
    }

    function countryColorFuncLargestGrowth(country) {
        if (selectedToDate === undefined || selectedFromDate === undefined) {
            return ["", "white"];
        }

        var leaning_data = get_percentage_leaning_data_between(data, newCountryCodes[country], selectedFromDate, selectedToDate);
        var dates = Object.keys(leaning_data);

        //leaning = leaning_mapper[selectedLeaning]
        first = leaning_data[dates[0]]
        last = leaning_data[dates.at(-1)]

        var growth = {};

        selectedLeanings.forEach(l => {
            var leaning = l;
            var mapped_leaning = leaning_mapper[l];
           
            if (
                first != undefined && last !== undefined && 
                last[mapped_leaning] !== undefined &&  first[mapped_leaning] !== undefined
            ) { 
                if (growth[mapped_leaning] === undefined) {
                    growth[mapped_leaning] = 0;
                }
                             
                growth[mapped_leaning] = last[mapped_leaning] - first[mapped_leaning];
            }
        });

        
        let largestGrowthEntry = Object.entries(growth).reduce((max, current) => {
            return (max[1] > current[1]) ? max : current;
        })[0]; 

        return [Math.round(growth[largestGrowthEntry]), leaning_colors[largestGrowthEntry], largestGrowthEntry]
    }

    function countryColorFuncLargestDecline(country) {
        if (selectedToDate === undefined || selectedFromDate === undefined) {
            return ["", "white"];
        }

        var leaning_data = get_percentage_leaning_data_between(data, newCountryCodes[country], selectedFromDate, selectedToDate);
        var dates = Object.keys(leaning_data);

        //leaning = leaning_mapper[selectedLeaning]
        first = leaning_data[dates[0]]
        last = leaning_data[dates.at(-1)]

        var growth = {};

        selectedLeanings.forEach(l => {
            var leaning = l;
            var mapped_leaning = leaning_mapper[l];
           
            if (
                first != undefined && last !== undefined && 
                last[mapped_leaning] !== undefined &&  first[mapped_leaning] !== undefined
            ) { 
                if (growth[mapped_leaning] === undefined) {
                    growth[mapped_leaning] = 0;
                }
                             
                growth[mapped_leaning] = last[mapped_leaning] - first[mapped_leaning];
            }
        });

        
        let largestDeclinerEntry = Object.entries(growth).reduce((min, current) => {
            return (min[1] < current[1]) ? min : current;
        })[0]; 
        

        return [Math.round(growth[largestDeclinerEntry]), leaning_colors[largestDeclinerEntry], largestDeclinerEntry]
    }

    function OnHoverCountry(countryCode) {
    }

    function OnClickCountry(countryCode) {
        // console.log("click: " + countryCode);
        selectCountry(countryCode)
        colorBorder();
    }

    let dates;

    function timestamp(str) {
        return new Date(str).getFullYear();
    }

    function selectCountry(country) {
        selectedCountry = country;
        document.getElementById("countryHeader").innerText = country;

        dates = get_all_dates(data, newCountryCodes[country]);
        selectedFromDate = dates.at(0);
        selectedToDate = dates.at(-1);

        let years = [...new Set(dates.map(date => new Date(date).getFullYear()))];

        var slider = document.getElementById('slider');

        if (!slider.noUiSlider) {
            noUiSlider.create(slider, {
                margin: 2,
                start: [timestamp(dates.at(0)), timestamp(dates.at(-1))],
                connect: true, // Display a colored bar between the handles
                range: {
                    'min': timestamp(dates.at(0)),
                    'max': timestamp(dates.at(-1))
                },
                pips: {
                    mode: 'values',
                    values: years, // Use the years array for the pips
                    density: dates.length,
                    snap: true  // Make the handle snap to the pips
                }
            });

            attachSliderUpdateListener(slider, dates);

            var pips = slider.querySelectorAll('.noUi-value');

            function clickOnPip() {
                var value = Number(this.getAttribute('data-value'));
                var values = slider.noUiSlider.get();
            
                // Convert the current values to numbers
                var valueLower = Number(values[0]);
                var valueUpper = Number(values[1]);
            
                // Determine which handle is closer to the clicked value
                var handleIndex = Math.abs(value - valueLower) < Math.abs(value - valueUpper) ? 0 : 1;
            
                // Create a new array for the handle positions
                var newValues = handleIndex === 0 ? [value, valueUpper] : [valueLower, value];
            
                // Set the new handle positions
                slider.noUiSlider.set(newValues);
            }
            
            for (var i = 0; i < pips.length; i++) {
        
                // For this example. Do this in CSS!
                pips[i].style.cursor = 'pointer';
                pips[i].addEventListener('click', clickOnPip);
            }

        // Add a click event listener to the slider
        slider.addEventListener('click', function(event) {
            // Get the clicked position
            var rect = slider.getBoundingClientRect();
            var x = event.clientX - rect.left; // x position within the element
            var width = rect.right - rect.left; // width of the element
            var percentage = x / width; // percentage of the clicked position in the element

            // Calculate the new value based on the clicked position
            var newValue = slider.noUiSlider.options.range.min + (slider.noUiSlider.options.range.max - slider.noUiSlider.options.range.min) * percentage;

            // Find the nearest allowed year
            var nearestYear = years.reduce(function(prev, curr) {
                return (Math.abs(curr - newValue) < Math.abs(prev - newValue) ? curr : prev);
            });

            // Get the current values
            var values = slider.noUiSlider.get();

            // Determine which handle is closer to the clicked value
            var handleIndex = Math.abs(nearestYear - values[0]) < Math.abs(nearestYear - values[1]) ? 0 : 1;

            // Create a new array for the handle positions
            var newValues = handleIndex === 0 ? [nearestYear, values[1]] : [values[0], nearestYear];

            // Set the slider handle to the nearest allowed year
            slider.noUiSlider.set(newValues);
        });
        

        } else {
            slider.noUiSlider.updateOptions({
                start: [timestamp(dates.at(0)), timestamp(dates.at(-1))],
                margin: 2,
                connect: true, // Display a colored bar between the handles
                range: {
                    'min': timestamp(dates.at(0)),
                    'max': timestamp(dates.at(-1))
                },
                pips: {
                    mode: 'values',
                    values: years, // Use the years array for the pips
                    density: dates.length,
                    snap: true  // Make the handle snap to the pips
                }
            }, true); // Reset existing options without adding new event listeners
        }

        colorMap();
        drawGraphs();
    }

    function attachSliderUpdateListener(slider) {
        slider.noUiSlider.on('update', function (values, handle) {
            var valueLower = document.getElementById('slider-value-lower');
            var valueUpper = document.getElementById('slider-value-upper');

            valueLower.innerHTML = Math.round(values[0]);
            valueUpper.innerHTML = Math.round(values[1]);


            var newFromDate = Math.round(values[0]).toString();
            var newToDate = Math.round(values[1]).toString();


            if (newFromDate != selectedFromDate || newToDate != selectedToDate) {
                colorMap();
                drawGraphs();

                selectedFromDate = newFromDate;
                selectedToDate = newToDate;
            }
        });
    }

    function interpolateRedGreen(t) {
        if (t < 0 || t > 1) {
            return 'Value must be between 0 and 1';
        }

        // Calculate red and green components
        const red = 255 * (1 - t);
        const green = 255 * t;

        // Convert each component to an integer
        const r = Math.round(red);
        const g = Math.round(green);

        // Return the color in hexadecimal format
        return `rgb(${r}, ${g}, 0)`;
    }

    function graph(country, date1, date2, svg) {
    var newCountryCodes = {
        "Austria": "AT",
        "Belgium": "BE",
        "Germany": "DE",
        "Denmark": "DK",
        "Greece": "EL",
        "Spain": "ES",
        "Finland": "FI",
        "France": "FR",
        "Ireland": "IE",
        "Italy": "IT",
        "Netherlands": "NL",
        "Portugal": "PT",
        "Sweden": "SE",
    }

    var growthData = [];
    var allYears = [];
    for (var year in data[newCountryCodes[country]].electionGrowth) {
        if (year >= date1 && year <= date2) {
            for (var leaning in data[newCountryCodes[country]].electionGrowth[year]) {
                var growth = data[newCountryCodes[country]].electionGrowth[year][leaning];
                growthData.push({
                    leaning: leaning,
                    year: year,
                    growth: growth.cumulative
                });
                allYears.push(year);
            }
        }
    }

    // console.log(growthData)

    // Find the min and max growth values
    var growthMin = d3.min(growthData, function(d) { return d.growth; });
    var growthMax = d3.max(growthData, function(d) { return d.growth; });

    // Create a scale for your growth data
    var growthScale = d3.scaleLinear()
        .domain([growthMin, growthMax])
        .range([0, 1]);

    // Get the parent container
    var graphContainer = document.getElementById('graph').parentNode;

    // Remove the old SVG
    //d3.select("#graph").remove();

    // Get the width and height of the graphContainer
    var width = graphContainer.clientWidth;
    var height = graphContainer.clientHeight - 110;

    // Create an SVG in the graphContainer
    svg = d3.select(graphContainer)
    .append("svg")
        .attr("id", "graph")
        .attr("width", width - 25)
        .attr("height", height / 1.75);

    // Define margins for the x-axis
    var xAxisMargin = 50;

    // Create a scale for your x-axis
    var x = d3.scalePoint()
    .domain(allYears)
    .range([xAxisMargin, width - 25 - xAxisMargin]); // Leave space on both sides of the x-axis

    // Create a scale for your y-axis
    var y = d3.scaleLinear()
    .domain([0, 1])
    .range([height / 2 - 20, 25]);

    // Add the y-axis to your SVG
    svg.append("g")
    .attr("transform", "translate(" + xAxisMargin + ",0)")
    .call(d3.axisLeft(y).ticks(5));

    // Add grid lines for each x-axis tick
    svg.selectAll(".grid-line")
        .data(x.domain())
        .enter()
        .append("line")
        .attr("class", "grid-line")
        .attr("stroke", "#ccc") // Change this to the color you want
        .attr("stroke-opacity", 0.9) // Make the lines slightly opaque
        .attr("y1", 0)
        .attr("y2", y(0)) // Adjust this to be the same as the y position of the x-axis
        .attr("x1", function(d) { return x(d); })
        .attr("x2", function(d) { return x(d); });

    // Define color scale
    var color = d3.scaleOrdinal()
    .domain(["far-left", "left", "center-left", "center", "center-right", "right", "far-right"])
    .range(["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"]);

    // Define your line
    var line = d3.line()
        .x(function(d) { return x(d.year); })
        .y(function(d) { return y(d.growth); });

    // Group the data by leaning
    var dataByLeaning = Array.from(d3.group(growthData, d => d.leaning));

    // Scale the growth data in dataByLeaning
    dataByLeaning = dataByLeaning.map(([key, values]) => {
        return [key, values.map(d => ({...d, growth: growthScale(d.growth)}))];
    });

    // Filter the data to include only the selected leanings
    var filteredDataByLeaning = dataByLeaning.filter(function([key, values]) {
        for (var l in selectedLeanings) {
            if (leaning_mapper[selectedLeanings[l]] == key) {
                return true;
            }
        }
        return false;
    });

    //console.log(filteredDataByLeaning)

    // Append your lines to the SVG
    filteredDataByLeaning.forEach(function([key, values]) {
        svg.append("path")
        .datum(values)
        .attr("fill", "none")
        .attr("stroke", color(key))
        .attr("stroke-width", 4)
        .attr("class", "line " + key.replace(/\s+/g, '-'))  // Add a class for easy selection
        .attr("d", line)
        .on("mouseover", function() {
            colorMap(key);
            d3.selectAll(".line").style("opacity", 0.1);  // Gray out all lines
            d3.selectAll("." + key.replace(/\s+/g, '-')).style("opacity", 1);  // Highlight the hovered line

            var checkboxes = document.querySelectorAll('#radio-leanings .form-check-input[type="checkbox"]');

                    checkboxes.forEach(element => {
                        if (element.id !== "radio-" + key) {
                            element.disabled = true;
                        }
                    });
        })
        .on("mouseout", function() {
            colorMap();
            d3.selectAll(".line").style("opacity", 1);  // Reset the opacity

            var checkboxes = document.querySelectorAll('#radio-leanings .form-check-input[type="checkbox"]');

            checkboxes.forEach(element => {
                    element.disabled = false;
            });
        });
    });

    // Add the x-axis to your SVG
    var xAxis = svg.append("g")
    .attr("transform", "translate(0," + y(0) + ")")
    .call(d3.axisBottom(x));

    // Move the x-axis labels to the bottom of the grid lines
    xAxis.selectAll("text")
    .attr("dy", "1em"); // Adjust this to move the labels below the x-axis
}

    function graphSurvey(country, date1, date2, svg, type) {
        var newCountryCodes = {
            "Austria": "AT",
            "Belgium": "BE",
            "Germany": "DE",
            "Denmark": "DK",
            "Greece": "EL",
            "Spain": "ES",
            "Finland": "FI",
            "France": "FR",
            "Ireland": "IE",
            "Italy": "IT",
            "Netherlands": "NL",
            "Portugal": "PT",
            "Sweden": "SE", 
        }

        var growthData = [];
        var allYears = [];
        for (var year in data[newCountryCodes[country]].surveyGrowth) {
            if (year >= date1 && year <= date2) {
                for (var leaning in data[newCountryCodes[country]].surveyGrowth[year]) {
                    var growth = data[newCountryCodes[country]].surveyGrowth[year][leaning];
                    //console.log(data[newCountryCodes[country]].surveyGrowth[year][leaning])

                    if (type === "happy") {
                        growthData.push({
                            leaning: leaning,
                            year: year,
                            growth: growth.happy.cumulative
                            /**growth: {
                                "happy": growth.happy,
                                "satisfaction": growth.satisfaction,
                                "trust_country": growth.trust_country,
                                "trust_eu": growth.trust_eu
                            }**/
                        });
                    }
                    else if (type === "satisfaction") {
                        growthData.push({
                            leaning: leaning,
                            year: year,
                            growth: growth.satisfaction.cumulative
                            /**growth: {
                                "happy": growth.happy,
                                "satisfaction": growth.satisfaction,
                                "trust_country": growth.trust_country,
                                "trust_eu": growth.trust_eu
                            }**/
                        });
                    }
                    else if (type === "trust_country") {
                        growthData.push({
                            leaning: leaning,
                            year: year,
                            growth: growth.trust_country.cumulative
                            /**growth: {
                                "happy": growth.happy,
                                "satisfaction": growth.satisfaction,
                                "trust_country": growth.trust_country,
                                "trust_eu": growth.trust_eu
                            }**/
                        });
                    }
                    else if (type === "trust_eu") {
                        growthData.push({
                            leaning: leaning,
                            year: year,
                            growth: growth.trust_eu.cumulative

                        });
                    }
                   
                    allYears.push(year);
                }
            }
        }

        // Find the min and max growth values
        var growthMin = d3.min(growthData, function(d) { return d.growth; });
        var growthMax = d3.max(growthData, function(d) { return d.growth; });

        // Create a scale for your growth data
        var growthScale = d3.scaleLinear()
            .domain([growthMin, growthMax])
            .range([0, 1]);

        // Get the parent container
        var graphContainer = document.getElementById('graph').parentNode;

        // Remove the old SVG
        //d3.select("#graph").remove();

        // Get the width and height of the graphContainer
        var width = graphContainer.clientWidth;
        var height = graphContainer.clientHeight - 210;

        // Create an SVG in the graphContainer
        svg = d3.select(graphContainer)
        .append("svg")
            .attr("id", "graph")
            .attr("width", width - 25)
            .attr("height", height / 1.75);

        // Define margins for the x-axis
        var xAxisMargin = 50;

        // Create a scale for your x-axis
        var x = d3.scalePoint()
        .domain(allYears) 
        .range([xAxisMargin, width - 25 - xAxisMargin]); // Leave space on both sides of the x-axis

        // Create a scale for your y-axis
        var y = d3.scaleLinear()
        .domain([0, 1]) 
        .range([height / 2, 25]); 

        // Add the y-axis to your SVG
        svg.append("g")
        .attr("transform", "translate(" + xAxisMargin + ",0)")
        .call(d3.axisLeft(y).ticks(5));

        // Add grid lines for each x-axis tick
        svg.selectAll(".grid-line")
            .data(x.domain())
            .enter()
            .append("line")
            .attr("class", "grid-line")
            .attr("stroke", "#ccc") // Change this to the color you want
            .attr("stroke-opacity", 0.9) // Make the lines slightly opaque
            .attr("y1", 0)
            .attr("y2", y(0)) // Adjust this to be the same as the y position of the x-axis
            .attr("x1", function(d) { return x(d); })
            .attr("x2", function(d) { return x(d); });


        // Define color scale
        var color = d3.scaleOrdinal()
        .domain(["far-left", "left", "center-left", "center", "center-right", "right", "far-right"])
        .range(["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"]);

        // Define your line
        var line = d3.line()
            .x(function(d) { return x(d.year); }) 
            .y(function(d) { return y(d.growth); });

        // Group the data by leaning
        var dataByLeaning = Array.from(d3.group(growthData, d => d.leaning));

        // Scale the growth data in dataByLeaning
        dataByLeaning = dataByLeaning.map(([key, values]) => {
            return [key, values.map(d => ({...d, growth: growthScale(d.growth)}))];
        });

        // Filter the data to include only the selected leanings
        var filteredDataByLeaning = []
        
        // Filter the data to include only the selected leanings
        var filteredDataByLeaning = dataByLeaning.filter(function([key, values]) {
            for (var l in selectedLeanings) {
                if (leaning_mapper[selectedLeanings[l]] == key) {
                    return true;
                }
            }
            return false;
        });

        //console.log(filteredDataByLeaning)

        // Append your lines to the SVG
        filteredDataByLeaning.forEach(function([key, values]) {
        svg.append("path")
        .datum(values)
        .attr("fill", "none")
        .attr("stroke", color(key))
        .attr("stroke-width", 4)
        .attr("class", "line " + key.replace(/\s+/g, '-'))  // Add a class for easy selection
        .attr("d", line)
        .on("mouseover", function() {
            colorMap(key);
            d3.selectAll(".line").style("opacity", 0.1);  // Gray out all lines
            d3.selectAll("." + key.replace(/\s+/g, '-')).style("opacity", 1);  // Highlight the hovered line

            var checkboxes = document.querySelectorAll('#radio-leanings .form-check-input[type="checkbox"]');

                    checkboxes.forEach(element => {
                        if (element.id !== "radio-" + key) {
                            element.disabled = true;
                        }
                    });
        })
        .on("mouseout", function() {
            colorMap();
            d3.selectAll(".line").style("opacity", 1);  // Reset the opacity

            var checkboxes = document.querySelectorAll('#radio-leanings .form-check-input[type="checkbox"]');

            checkboxes.forEach(element => {
                    element.disabled = false;
            });
        });
    });

        // Add the x-axis to your SVG
        var xAxis = svg.append("g")
        .attr("transform", "translate(0," + y(0) + ")")
        .call(d3.axisBottom(x));

        // Move the x-axis labels to the bottom of the grid lines
        xAxis.selectAll("text")
        .attr("dy", "1em"); // Adjust this to move the labels below the x-axis
    }

  
    
    function selectMapMode(radio, type) {
        if (radio.checked) {
            selectedMapMode = type;
            
            if (selectedMapMode === "largest-growth") {
                selectedCountryColorFunc= countryColorFuncLargestGrowth;
            }
            else if (selectedMapMode === "largest-decline") {
                selectedCountryColorFunc= countryColorFuncLargestDecline; 
            }
            else if (selectedMapMode === "cumulative-growth") {
                selectedCountryColorFunc = countryColorFuncCumulativeGrowth;
            }
            colorMap();
           
        }
    }

    function selectSurvey(radio, type) {
        if (radio.checked) {
            selectedSurveyType = type;

            var graphContainer = document.getElementById('graph').parentNode;
            
            // Remove all child elements of the graphContainer
            graphContainer.removeChild(graphContainer.lastChild);

            graphSurvey(selectedCountry, selectedFromDate, selectedToDate, graphContainer, type);
        }
    }


    

</script>

</body>

</html>

<style>

</style>